using Limilabs.Mail;
using Limilabs.Mail.Licensing;
using System;
using System.Collections.Generic;
using System.ComponentModel.Composition;
using System.Data;
using System.Data.Entity.Validation;
using System.Linq;
using System.Security.Cryptography;
using System.Security.Permissions;
using System.Text;
using System.Threading.Tasks;
using VecompSoftware.BPM.Integrations.Modules.***REMOVED***.Malware.Configurations;
using VecompSoftware.BPM.Integrations.Modules.***REMOVED***.Malware.Data;
using VecompSoftware.BPM.Integrations.Modules.***REMOVED***.Malware.Data.Core.PECAttachments;
using VecompSoftware.BPM.Integrations.Modules.***REMOVED***.Malware.Data.Entities;
using VecompSoftware.BPM.Integrations.Modules.***REMOVED***.Malware.Models;
using VecompSoftware.BPM.Integrations.Services.BiblosDS;
using VecompSoftware.BPM.Integrations.Services.BiblosDS.DocumentService;
using VecompSoftware.BPM.Integrations.Services.ServiceBus;
using VecompSoftware.BPM.Integrations.Services.WebAPI;
using VecompSoftware.DocSuiteWeb.Common.CustomAttributes;
using VecompSoftware.DocSuiteWeb.Common.Helpers;
using VecompSoftware.DocSuiteWeb.Common.Loggers;
using VecompSoftware.DocSuiteWeb.Entity.PECMails;
using VecompSoftware.Services.Command.CQRS.Events.Entities.PECMails;

namespace VecompSoftware.BPM.Integrations.Modules.***REMOVED***.Malware
{
    [Export(typeof(IModule))]
    [LogCategory(ModuleConfigurationHelper.MODULE_NAME)]
    public class Execution : ModuleBase
    {
        #region [ Fields ]
        private readonly ILogger _logger;
        private readonly IWebAPIClient _webAPIClient;
        private readonly IServiceBusClient _serviceBusClient;
        private readonly IDocumentClient _documentClient;
        private readonly IPECAttachmentRepository _pecAttachmentRepository;
        private static IEnumerable<LogCategory> _logCategories;
        private readonly ModuleConfigurationModel _moduleConfiguration;
        private readonly IList<Guid> _subscriptions = new List<Guid>();
        private bool _needInitializeModule = false;
        #endregion

        #region [ Properties ]
        private static IEnumerable<LogCategory> LogCategories
        {
            get
            {
                if (_logCategories == null)
                {
                    _logCategories = LogCategoryHelper.GetCategoriesAttribute(typeof(Execution));
                }
                return _logCategories;
            }
        }
        #endregion

        #region [ Constructor ]
        [ImportingConstructor]
        public Execution(ILogger logger, IServiceBusClient serviceBusClient, IWebAPIClient webAPIClient, IDocumentClient documentClient)
            : base(logger, ModuleConfigurationHelper.MODULE_NAME)
        {
            try
            {
                _logger = logger;
                _webAPIClient = webAPIClient;
                _documentClient = documentClient;
                _moduleConfiguration = ModuleConfigurationHelper.GetModuleConfiguration();
                _pecAttachmentRepository = new PECAttachmentRepository(new MalwareDbContext(_logger, ModuleConfigurationHelper.JsonSerializerSettings, _moduleConfiguration.DatabaseConnectionString));
                _serviceBusClient = serviceBusClient;
                _needInitializeModule = true;
            }
            catch (Exception ex)
            {
                _logger.WriteError(new LogMessage("***REMOVED***.Malware -> Critical error in construction module"), ex, LogCategories);
                throw;
            }
        }
        #endregion

        #region [ Methods ]
        protected override void Execute()
        {
            if (Cancel)
            {
                return;
            }

            try
            {
                InitializeModule();
            }
            catch (Exception ex)
            {
                _logger.WriteError(new LogMessage("***REMOVED***.Malware -> Critical Error"), ex, LogCategories);
                throw;
            }
        }

        protected override void OnStop()
        {
            CleanSubscriptions();
            _logger.WriteInfo(new LogMessage("OnStop -> ***REMOVED***.Malware"), LogCategories);
        }

        private void InitializeModule()
        {
            if (_needInitializeModule)
            {
                _logger.WriteDebug(new LogMessage("Initialize module"), LogCategories);
                string fileName = LicenseHelper.GetLicensePath();
                _logger.WriteInfo(new LogMessage($"Limilabs check licence in path {fileName}"), LogCategories);
                new FileIOPermission(FileIOPermissionAccess.Read, fileName).Assert();
                LicenseStatus status = LicenseHelper.GetLicenseStatus();

                _logger.WriteInfo(new LogMessage($"Limilabs licence status is {status}"), LogCategories);
                switch (status)
                {
                    case LicenseStatus.Exception:
                    case LicenseStatus.InvalidXml:
                    case LicenseStatus.InvalidSignature:
                    case LicenseStatus.InvalidLicenseXml:
                    case LicenseStatus.Revoked:
                    case LicenseStatus.Invalid:
                        throw new Exception($"Licenza Limilabs non valida in quanto la validazione ha prodotto lo stato {status}");
                    case LicenseStatus.NoLicenseFile:
                        throw new Exception($"Licenza Limilabs non trovata nel percorso {fileName}");
                }

                _serviceBusClient.StartListening<IEventCreatePECMail>(ModuleConfigurationHelper.MODULE_NAME, _moduleConfiguration.TopicName,
                    _moduleConfiguration.SubscriptionName, CreatePECMalwareCallback);
                _needInitializeModule = false;
            }
        }

        private async Task CreatePECMalwareCallback(IEventCreatePECMail evt, IDictionary<string, object> properties)
        {
            PECMail pecMail = evt.ContentType.ContentTypeValue;
            string username = evt.Identity.User;
            List<PECAttachment> pecAttachments = await InitializeModel(pecMail, username);
            foreach (PECAttachment pecAttachment in pecAttachments)
            {
                _logger.WriteDebug(new LogMessage($"***REMOVED***.Malware -> Prepare inserting PECAttachment with document id {pecAttachment.DocumentId}..."), LogCategories);
                try
                {
                    _pecAttachmentRepository.Add(pecAttachment);
                    _logger.WriteInfo(new LogMessage($"***REMOVED***.Malware -> PECAttachment with document id {pecAttachment.DocumentId} was successfully inserted."), LogCategories);
                }
                catch (Exception ex)
                {
                    throw new Exception($"***REMOVED***.Malware -> Insert failed for PEC Attachment with id {pecMail.UniqueId}; error message: {ex.Message}");
                }
            }
        }

        private async Task<List<PECAttachment>> InitializeModel(PECMail pecMail, string username)
        {
            List<PECAttachment> pecAttachments = new List<PECAttachment>();
            foreach (PECMailAttachment pecMailAttachment in pecMail.Attachments)
            {
                _logger.WriteDebug(new LogMessage($"***REMOVED***.Malware -> Prepare PECAttachment with id {pecMailAttachment.EntityId}"), LogCategories);

                #region [ Check if document exists ]
                _logger.WriteDebug(new LogMessage($"***REMOVED***.Malware -> Checking if document with id {pecMailAttachment.IDDocument} already esists in the database"), LogCategories);
                if (_pecAttachmentRepository.DocumentExists(pecMailAttachment.IDDocument.Value))
                {
                    _logger.WriteWarning(new LogMessage($"***REMOVED***.Malware -> Documento {pecMailAttachment.IDDocument} esiste già nel DB."), LogCategories);
                    continue;
                }
                #endregion

                #region [ Create hash SHA256 of the document ]
                _logger.WriteDebug(new LogMessage($"***REMOVED***.Malware -> Hashing document with id {pecMailAttachment.IDDocument} content in SHA256 format"), LogCategories);
                Content documentContent = await _documentClient.GetDocumentContentByIdAsync(pecMailAttachment.IDDocument.Value);
                string documentHash = string.Empty;
                using (SHA256CryptoServiceProvider alg = new SHA256CryptoServiceProvider())
                {
                    byte[] hashByte = alg.ComputeHash(documentContent.Blob);
                    StringBuilder hashCode = new StringBuilder();
                    for (int i = 0; i < hashByte.Length; i++)
                    {
                        hashCode.Append(hashByte[i].ToString("X2"));
                    }
                    documentHash = hashCode.ToString();
                }
                #endregion

                ArchiveDocument document = await _documentClient.GetInfoDocumentAsync(pecMailAttachment.IDDocument.Value);

                #region [ Reconstruct Mail for getting ReplyTo header ]
                _logger.WriteDebug(new LogMessage($"***REMOVED***.Malware -> Getting reply-to header from mail with id {pecMail.IDMailContent}"), LogCategories);
                List<Document> mailDocumentList = await _documentClient.GetDocumentChildrenAsync(pecMail.IDMailContent.Value);
                Content mailContent = await _documentClient.GetDocumentContentByIdAsync(mailDocumentList.FirstOrDefault().IdDocument);
                IMail mail = new MailFactory().CreateMail(mailContent.Blob);
                string replyTo = string.Join(";", mail.ReplyTo
                    .SelectMany(x => x.GetMailboxes())
                    .Select(x => x.Address));
                #endregion

                pecAttachments.Add(new PECAttachment()
                {
                    DocumentId = pecMailAttachment.IDDocument,
                    SHA256 = documentHash,
                    FileName = document.Name,
                    Subject = pecMail.MailSubject,
                    Sender = pecMail.MailSenders,
                    ReplyTo = replyTo,
                    Recipient = pecMail.MailRecipients,
                    MailDate = pecMail.MailDate,
                    RegistrationUser = username
                });
                _logger.WriteDebug(new LogMessage($"***REMOVED***.Malware -> PECAttachment with id {pecMailAttachment.EntityId} was built"), LogCategories);
            }
            return pecAttachments;
        }

        internal void CleanSubscriptions()
        {
            foreach (Guid item in _subscriptions)
            {
                _serviceBusClient.CloseListeningAsync(item).Wait();
            }
            _subscriptions.Clear();
            _needInitializeModule = true;
        }
        #endregion
    }
}
